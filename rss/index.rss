<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Good Kid, Hack City</title><description>A journey</description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Sun, 25 Oct 2015 19:56:54 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>On Backbone</title><description>&lt;p&gt;I've been learning how to utilize the Backbone framework recently and I wanted to share some of my findings.  While flexibility is a point in Backbone's favor, this seems to have lead to a lack of agreed-upon best practices and some uncertainty on how exactly to fit the various views&lt;/p&gt;</description><link>http://localhost:2368/on-backbone/</link><guid isPermaLink="false">b5691711-4975-4bed-9266-5e1d0b74d574</guid><dc:creator>Adam Grimm</dc:creator><pubDate>Sun, 25 Oct 2015 19:53:22 GMT</pubDate><content:encoded>&lt;p&gt;I've been learning how to utilize the Backbone framework recently and I wanted to share some of my findings.  While flexibility is a point in Backbone's favor, this seems to have lead to a lack of agreed-upon best practices and some uncertainty on how exactly to fit the various views and models together.  Below is some of my insight on the matter.&lt;/p&gt;

&lt;h5 id="views"&gt;Views&lt;/h5&gt;

&lt;p&gt;Views are used to generate and interact with everything on the DOM.  Each view should represent some cohesive unit displayed on the DOM.  Often, a parent view will contain multiple sub-views for each unit created.  For example, on a twitter-esque application, views would be created for each tweet displayed.  A parent view would hold all of these tweet views and represent the 'tweets' area of the page.  &lt;/p&gt;

&lt;p&gt;When variable data is required to generate the view, a model or collection should be included in the view to hold that data.  If the DOM elements do not rely on a changing data source, no model is required.&lt;/p&gt;

&lt;p&gt;Views listen to DOM events via the 'events' object, which is a Backbone-supported property of the View class.  If a view needs to listen for model or view events, these listeners are created upon initialization of the view (typically).  They should not be put in the 'events' property.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Views should only be used to interact with the DOM.&lt;/strong&gt;  Any code required to manipulate data should be passed off to the corresponding model or collection.&lt;/p&gt;

&lt;h5 id="models"&gt;Models&lt;/h5&gt;

&lt;p&gt;Models contain and interact with the app's data.  Like views, models should be created to represent a cohesive set of data, to as low of a level as makes sense.  For example, while one model could be used to hold all of the messages displayed on the screen in a chat application, instead each message should be represented by its own model.  If there are a group of models of the same type, these can all be wrapped up in a Collection.&lt;/p&gt;

&lt;p&gt;Models are often properties of views, but never the other way around.  This means that when the user provides data via the DOM, the View must pass that information off to its model.  The model cannot listen for the data or events directly.  Models can however listen for other model events if they are included as properties.&lt;/p&gt;

&lt;p&gt;This may tempt the designer to nest models within other models for the sake of event listening when the application structures does not merit this.  To keep everything organized and clean, models should only have sub-models as properties when it is logical that the sub-model would belong to its parent in the context of the application.  This can sometimes lead to data being passed through multiple models and views to arrive at their necessary destination.  This is ok!  It is far easier to grok the flow of data through your Backbone application when a coherent and logical framework is established.&lt;/p&gt;

&lt;p&gt;Application-logic should be placed in the lowest level model possible.  For example, it is possible to send all data up to the highest-level model and allow decision making to occur there.  However, it is preferred to let the sub-models handle this logic at the lowest-level possible.  In this way, tasks are delegated in a consistent manner.&lt;/p&gt;

&lt;h5 id="collections"&gt;Collections&lt;/h5&gt;

&lt;p&gt;Collections represent a group of same-type Models that behave similarly.  Frankly, I'm not entirely sure what the upside is for using a Collection in place of a Model, which could potentially store an array or object of sub-models.  It seems like Backbone recognizes that this is a very common pattern and has provided a Collection class with some helper functions to better help you manage the sub-models.  I think it is most helpful to think of Collections in the same way as Models, but for a specific use.&lt;/p&gt;

&lt;h5 id="somebigpicturestuff"&gt;Some Big Picture Stuff&lt;/h5&gt;

&lt;p&gt;As I get more familiar with the idea of an MVC framework, it becomes more apparent to me that the bottom line is not always efficiency and ease-of-use.  Passing data around the models and views can be inefficient and generate unnecessary code.  So why do we do it?&lt;/p&gt;

&lt;p&gt;The benefit is a consistent structure and modularity.  As my applications get larger and more complex, it becomes very obvious that having a home for each piece of your code is extremely advantageous.  When new logic must be introduced, it should be apparent where in your framework it should go.  The structure of your application and the structure of your code are mirrored, which greatly contributes to the concept of self-documenting code.  &lt;/p&gt;

&lt;p&gt;Ultimately, working with a framework for the first time can be frustrating, as it restricts the developer's ability to do certain things.  Hopefully this post will help you understand how to make the framework work for you instead of the other way around!&lt;/p&gt;</content:encoded></item><item><title>Scrabble Tree</title><description>&lt;p&gt;The problem: design a data structure that finds every English word that can be made from a given bag of Scrabble letters&lt;/p&gt;

&lt;p&gt;What data structure is best suited for this application?  In contemplating this problem, I imagined a structure that contained every word, and as we queried it with a&lt;/p&gt;</description><link>http://localhost:2368/scrabble-tree/</link><guid isPermaLink="false">19e3682e-9493-416d-8f47-31162737341e</guid><dc:creator>Adam Grimm</dc:creator><pubDate>Mon, 12 Oct 2015 05:23:36 GMT</pubDate><content:encoded>&lt;p&gt;The problem: design a data structure that finds every English word that can be made from a given bag of Scrabble letters&lt;/p&gt;

&lt;p&gt;What data structure is best suited for this application?  In contemplating this problem, I imagined a structure that contained every word, and as we queried it with a group of letters, the list of potential words we could find would decrease as we removed each letter from our list until we honed in on our desired results.  &lt;/p&gt;

&lt;p&gt;I think a tree is the best answer here.  We can build a tree in which each node holds a letter, and the children of each node represent the subset of words that begin with the letters we have traversed to get to this node.&lt;/p&gt;

&lt;p&gt;For example, if we wanted to build this data structure using only the words "be", "bee", "been", "beer", and "beg", it would look like this: &lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/10/Tree-1.png" alt="example tree"&gt;&lt;/p&gt;

&lt;p&gt;The periods are used to indicate the end of a word.&lt;/p&gt;

&lt;p&gt;When we want to find words from a collection of letters, we travel down the tree, looking for children that are in our letters collection.  When we find a period, we know we have completed a word and can bubble that result back up the chain.  In pseudocode, the function looks like this:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function findWords(letters){
  declare a foundWords array
  remove the current letter from the letters array
  if this.children contains '.'
    add the current letter to foundWords&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iterate over all of this's children
  if you find a letter in the letters array
    call findWords on that child, passing in letters
    prepend the current letter to each value returned from the child's findWords call
    add these values to the foundWords array&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;return foundWords
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I'm not certain what the time complexity of this operation is.  Looking for words involves iterating over a node's children, finding one (or more), and then iterating over that node's children etc etc until we run out of letters to search for.  We don't have to look at every node; large swaths of the tree are almost certain to be ignored in each lookup.  However, more words in the tree does mean the operation will likely take longer, as you will probably find more words.  Does this point to linear time?&lt;/p&gt;

&lt;p&gt;Or, is the operation linear with respect to the number of letters you are searching for?  &lt;/p&gt;

&lt;p&gt;Anyone have any insight in this?&lt;/p&gt;</content:encoded></item><item><title>The Basics</title><description>&lt;p&gt;Hi.  I started a blog.  Surprised?  Me too.  But I told myself I'm going to jump into this thing with two feet.  Here's my best effort.&lt;/p&gt;

&lt;h3 id="what"&gt;What?&lt;/h3&gt;

&lt;p&gt;I moved to San Francisco to attend Hack Reactor, an accelerated learning program designed to equip me with the required tools to be&lt;/p&gt;</description><link>http://localhost:2368/first-for-everything/</link><guid isPermaLink="false">23c3b709-c246-439e-a693-e82c0017fb87</guid><dc:creator>Adam Grimm</dc:creator><pubDate>Tue, 29 Sep 2015 02:51:29 GMT</pubDate><content:encoded>&lt;p&gt;Hi.  I started a blog.  Surprised?  Me too.  But I told myself I'm going to jump into this thing with two feet.  Here's my best effort.&lt;/p&gt;

&lt;h3 id="what"&gt;What?&lt;/h3&gt;

&lt;p&gt;I moved to San Francisco to attend Hack Reactor, an accelerated learning program designed to equip me with the required tools to be a software engineer.  Some of those tools involve engineering software.  One of those tools is, apparently, blogging.  So this is that blog.  I intend to write about stuff I learn in and out of class.  Hopefully not too much personal stuff, for everyone's sake.&lt;/p&gt;

&lt;h3 id="who"&gt;Who?&lt;/h3&gt;

&lt;p&gt;Adam Tobias Grimm.  Born 15 November 1986.  Caucasian male from the Midwest.  Studied Chemical Engineering at Washington University in Saint Louis.  Employed in that field 2008-2015.&lt;/p&gt;

&lt;p&gt;I'm a Scorpio.&lt;/p&gt;

&lt;h3 id="why"&gt;Why?&lt;/h3&gt;

&lt;p&gt;According to &lt;a href="http://blog.codinghorror.com/the-one-thing-every-software-engineer-should-know/"&gt;this&lt;/a&gt;, to give myself the best shot at my potential career in software development, I need to market myself.  This is a new paradigm for me (or at least, buying into it is new to me) but lots of things are new right now so why not this?  &lt;/p&gt;

&lt;h3 id="when"&gt;When?&lt;/h3&gt;

&lt;p&gt;All day, every day.  &lt;/p&gt;</content:encoded></item></channel></rss>